# -*- coding: utf-8 -*-
"""debris

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y2eMikI7Y3iS-ozg3LTiUM6xg7badCdh
"""

import numpy as np
import matplotlib.pyplot as plt

# Constants
G = 6.67430e-11  # gravitational constant (m^3 kg^-1 s^-2)
M = 5.972e24      # mass of Earth (kg)
R = 6371e3        # radius of Earth (m)

# Function to calculate orbital velocity
def orbital_velocity(h):
    return np.sqrt(G * M / (R + h))

# Function to simulate space debris motion
def simulate_space_debris(h0, v0, t_max, dt):
    # Initial conditions
    h = h0  # initial altitude (m)
    v = v0  # initial velocity (m/s)
    t = 0   # initial time (s)

    # Lists to store data for plotting
    altitudes = [h]
    velocities = [v]
    times = [t]

    # Simulation loop
    while t < t_max:
        # Update acceleration (neglecting atmospheric drag)
        a = -G * M / (R + h)**2

        # Update velocity using Euler's method
        v += a * dt

        # Update altitude
        h += v * dt

        # Update time
        t += dt

        # Append data to lists
        altitudes.append(h)
        velocities.append(v)
        times.append(t)

    return times, altitudes, velocities

# Simulation parameters
h0 = 200e3        # initial altitude (m)
v0 = orbital_velocity(h0)  # initial velocity (m/s)
t_max = 20000     # maximum simulation time (s)
dt = 1            # time step (s)

# Simulate space debris motion
times, altitudes, velocities = simulate_space_debris(h0, v0, t_max, dt)

# Plot altitude vs. time
plt.figure(figsize=(10, 6))
plt.plot(times, altitudes)
plt.xlabel('Time (s)')
plt.ylabel('Altitude (m)')
plt.title('Space Debris Altitude vs. Time')
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

# Constants
G = 6.67430e-11  # gravitational constant (m^3 kg^-1 s^-2)
M = 5.972e24      # mass of Earth (kg)
R = 6371e3        # radius of Earth (m)

# Function to calculate orbital velocity
def orbital_velocity(h):
    return np.sqrt(G * M / (R + h))

# Function to simulate space debris motion
def simulate_space_debris(h0, v0, t_max, dt):
    # Initial conditions
    h = h0  # initial altitude (m)
    v = v0  # initial velocity (m/s)
    t = 0   # initial time (s)

    # Lists to store data for plotting
    altitudes = [h]
    velocities = [v]
    times = [t]

    # Simulation loop
    while t < t_max:
        # Update acceleration (neglecting atmospheric drag)
        a = -G * M / (R + h)**2

        # Update velocity using Euler's method
        v += a * dt

        # Update altitude
        h += v * dt

        # Update time
        t += dt

        # Append data to lists
        altitudes.append(h)
        velocities.append(v)
        times.append(t)

    return times, altitudes, velocities

# Simulation parameters
h0 = 200e3        # initial altitude (m)
v0 = orbital_velocity(h0)  # initial velocity (m/s)
t_max = 20000     # maximum simulation time (s)
dt = 1            # time step (s)

# Simulate space debris motion
times, altitudes, velocities = simulate_space_debris(h0, v0, t_max, dt)

# Plot altitude vs. time
plt.figure(figsize=(10, 6))
plt.plot(times, altitudes, color='b', linewidth=2, label='Altitude')
plt.xlabel('Time (s)', fontsize=14)
plt.ylabel('Altitude (m)', fontsize=14)
plt.title('Space Debris Altitude vs. Time', fontsize=16)
plt.grid(True)

# Add a horizontal line for Earth's surface
plt.axhline(y=R, color='r', linestyle='--', label='Earth Surface')

# Customize tick labels
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)

# Add legend
plt.legend(fontsize=12)

# Show plot
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize

# Constants
G = 6.67430e-11  # gravitational constant (m^3 kg^-1 s^-2)
M = 5.972e24      # mass of Earth (kg)
R = 6371e3        # radius of Earth (m)

# Function to calculate orbital velocity
def orbital_velocity(h):
    return np.sqrt(G * M / (R + h))

# Function to simulate space debris motion
def simulate_space_debris(h0, v0, t_max, dt):
    # Initial conditions
    h = h0  # initial altitude (m)
    v = v0  # initial velocity (m/s)
    t = 0   # initial time (s)

    # Lists to store data for plotting
    altitudes = [h]
    velocities = [v]
    times = [t]

    # Simulation loop
    while t < t_max:
        # Update acceleration (neglecting atmospheric drag)
        a = -G * M / (R + h)**2

        # Update velocity using Euler's method
        v += a * dt

        # Update altitude
        h += v * dt

        # Update time
        t += dt

        # Append data to lists
        altitudes.append(h)
        velocities.append(v)
        times.append(t)

    return times, altitudes, velocities

# Simulation parameters
h0 = 200e3        # initial altitude (m)
v0 = orbital_velocity(h0)  # initial velocity (m/s)
t_max = 20000     # maximum simulation time (s)
dt = 1            # time step (s)

# Simulate space debris motion
times, altitudes, velocities = simulate_space_debris(h0, v0, t_max, dt)

# Create a colormap based on altitude
norm = Normalize(vmin=min(altitudes), vmax=max(altitudes))
cmap = plt.cm.viridis

# Plot altitude vs. time using a scatter plot
plt.figure(figsize=(10, 6))
plt.scatter(times, altitudes, c=altitudes, cmap=cmap, s=50, alpha=0.8, edgecolors='k', linewidths=0.5)
plt.xlabel('Time (s)', fontsize=14)
plt.ylabel('Altitude (m)', fontsize=14)
plt.title('Space Debris Altitude vs. Time', fontsize=16)
plt.colorbar(label='Altitude (m)')
plt.grid(True)

# Show plot
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Constants
G = 6.67430e-11  # gravitational constant (m^3 kg^-1 s^-2)
M = 5.972e24      # mass of Earth (kg)
R = 6371e3        # radius of Earth (m)

# Function to calculate orbital velocity
def orbital_velocity(h):
    return np.sqrt(G * M / (R + h))

# Function to simulate space debris motion
def simulate_space_debris(h0, v0, t_max, dt):
    # Initial conditions
    h = h0  # initial altitude (m)
    v = v0  # initial velocity (m/s)
    t = 0   # initial time (s)

    # Lists to store data for plotting
    altitudes = [h]
    velocities = [v]
    times = [t]

    # Simulation loop
    while t < t_max:
        # Update acceleration (neglecting atmospheric drag)
        a = -G * M / (R + h)**2

        # Update velocity using Euler's method
        v += a * dt

        # Update altitude
        h += v * dt

        # Update time
        t += dt

        # Append data to lists
        altitudes.append(h)
        velocities.append(v)
        times.append(t)

    return times, altitudes, velocities

# Simulation parameters
h0 = 200e3        # initial altitude (m)
v0 = orbital_velocity(h0)  # initial velocity (m/s)
t_max = 20000     # maximum simulation time (s)
dt = 1            # time step (s)

# Simulate space debris motion
times, altitudes, velocities = simulate_space_debris(h0, v0, t_max, dt)

# Plot altitude vs. time using a line plot with markers
plt.figure(figsize=(10, 6))
plt.plot(times, altitudes, marker='o', markersize=5, color='b', linestyle='-', linewidth=2)
plt.xlabel('Time (s)', fontsize=14)
plt.ylabel('Altitude (m)', fontsize=14)
plt.title('Space Debris Altitude vs. Time', fontsize=16)
plt.grid(True)

# Show plot
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Constants
G = 6.67430e-11  # gravitational constant (m^3 kg^-1 s^-2)
M = 5.972e24      # mass of Earth (kg)
R = 6371e3        # radius of Earth (m)

# Function to calculate orbital velocity
def orbital_velocity(h):
    return np.sqrt(G * M / (R + h))

# Function to simulate space debris motion
def simulate_space_debris(h0, v0, t_max, dt):
    # Initial conditions
    h = h0  # initial altitude (m)
    v = v0  # initial velocity (m/s)
    t = 0   # initial time (s)

    # Lists to store data for plotting
    altitudes = [h]
    velocities = [v]
    times = [t]

    # Simulation loop
    while t < t_max:
        # Update acceleration (neglecting atmospheric drag)
        a = -G * M / (R + h)**2

        # Update velocity using Euler's method
        v += a * dt

        # Update altitude
        h += v * dt

        # Update time
        t += dt

        # Append data to lists
        altitudes.append(h)
        velocities.append(v)
        times.append(t)

    return times, altitudes, velocities

# Simulation parameters
h0 = 200e3        # initial altitude (m)
v0 = orbital_velocity(h0)  # initial velocity (m/s)
t_max = 20000     # maximum simulation time (s)
dt = 1            # time step (s)

# Simulate space debris motion
times, altitudes, velocities = simulate_space_debris(h0, v0, t_max, dt)

# Create 3D plot
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

# Plot altitude vs. time vs. velocity
ax.plot(times, altitudes, velocities, marker='o', markersize=5, color='b', linestyle='-')
ax.set_xlabel('Time (s)', fontsize=14)
ax.set_ylabel('Altitude (m)', fontsize=14)
ax.set_zlabel('Velocity (m/s)', fontsize=14)
ax.set_title('Space Debris Motion', fontsize=16)
ax.grid(True)

# Show plot
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Constants
G = 6.67430e-11  # gravitational constant (m^3 kg^-1 s^-2)
M = 5.972e24      # mass of Earth (kg)
R = 6371e3        # radius of Earth (m)

# Function to calculate orbital velocity
def orbital_velocity(h):
    return np.sqrt(G * M / (R + h))

# Function to simulate space debris motion
def simulate_space_debris(h0, v0, t_max, dt):
    # Initial conditions
    h = h0  # initial altitude (m)
    v = v0  # initial velocity (m/s)
    t = 0   # initial time (s)

    # Lists to store data for plotting
    altitudes = [h]
    velocities = [v]
    times = [t]

    # Simulation loop
    while t < t_max:
        # Update acceleration (neglecting atmospheric drag)
        a = -G * M / (R + h)**2

        # Update velocity using Euler's method
        v += a * dt

        # Update altitude
        h += v * dt

        # Update time
        t += dt

        # Append data to lists
        altitudes.append(h)
        velocities.append(v)
        times.append(t)

    return times, altitudes, velocities

# Simulation parameters
h0 = 200e3        # initial altitude (m)
v0 = orbital_velocity(h0)  # initial velocity (m/s)
t_max = 20000     # maximum simulation time (s)
dt = 1            # time step (s)

# Simulate space debris motion
times, altitudes, velocities = simulate_space_debris(h0, v0, t_max, dt)

# Create 3D scatter plot
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

# Plot altitude vs. time vs. velocity using scatter plot
ax.scatter(times, altitudes, velocities, c=altitudes, cmap='viridis', s=50, alpha=0.8)
ax.set_xlabel('Time (s)', fontsize=14)
ax.set_ylabel('Altitude (m)', fontsize=14)
ax.set_zlabel('Velocity (m/s)', fontsize=14)
ax.set_title('Space Debris Motion', fontsize=16)
ax.grid(True)

# Show plot
plt.show()

import numpy as np
import plotly.graph_objects as go

# Constants
G = 6.67430e-11  # gravitational constant (m^3 kg^-1 s^-2)
M = 5.972e24      # mass of Earth (kg)
R = 6371e3        # radius of Earth (m)
LEO_altitude = 2000e3  # Low Earth Orbit altitude (m)

# Function to calculate orbital velocity
def orbital_velocity(h):
    return np.sqrt(G * M / (R + h))

# Function to simulate space debris motion
def simulate_space_debris(h0, v0, t_max, dt):
    # Initial conditions
    h = h0  # initial altitude (m)
    v = v0  # initial velocity (m/s)
    t = 0   # initial time (s)

    # Lists to store data for plotting
    x_data = [R + h0]  # x-coordinate (Earth radius + initial altitude)
    y_data = [0]       # y-coordinate (Earth's equator)
    z_data = [0]       # z-coordinate (0, as orbit is in the equatorial plane)

    # Simulation loop
    while t < t_max:
        # Update acceleration (neglecting atmospheric drag)
        a = -G * M / (R + h)**2

        # Update velocity using Euler's method
        v += a * dt

        # Update altitude
        h += v * dt

        # Calculate the current position coordinates
        x = (R + h) * np.cos(v * t / (R + h))
        y = (R + h) * np.sin(v * t / (R + h))

        # Append data to lists
        x_data.append(x)
        y_data.append(y)
        z_data.append(0)  # Orbit is in the equatorial plane

        # Update time
        t += dt

    return x_data, y_data, z_data

# Simulation parameters
h0 = LEO_altitude  # initial altitude (m)
v0 = orbital_velocity(h0)  # initial velocity (m/s)
t_max = 3600  # simulation time (s), 1 hour
dt = 1  # time step (s)

# Simulate space debris motion
x_data, y_data, z_data = simulate_space_debris(h0, v0, t_max, dt)

# Create 3D scatter plot
fig = go.Figure(data=[go.Scatter3d(x=x_data, y=y_data, z=z_data, mode='lines')])
fig.update_layout(title='Space Debris Motion in LEO',
                  scene=dict(
                      xaxis=dict(title='X (m)'),
                      yaxis=dict(title='Y (m)'),
                      zaxis=dict(title='Z (m)'),
                  ))
fig.show()

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Constants
G = 6.67430e-11  # gravitational constant (m^3 kg^-1 s^-2)
M = 5.972e24  # mass of the Earth (kg)
R = 6371000.0  # radius of the Earth (m)

# Initial conditions for the debris
x0 = 7000e3  # initial x position (m)
y0 = 0.0  # initial y position (m)
z0 = 0.0  # initial z position (m)
vx0 = 0.0  # initial velocity in x direction (m/s)
vy0 = 7500.0  # initial velocity in y direction (m/s)
vz0 = 0.0  # initial velocity in z direction (m/s)

# Time parameters
dt = 1.0  # time step (s)
t_max = 6000.0  # maximum simulation time (s)
num_steps = int(t_max / dt)

# Arrays to store positions
t_values = np.zeros(num_steps)
x_values = np.zeros(num_steps)
y_values = np.zeros(num_steps)
z_values = np.zeros(num_steps)

# Initial conditions
t_values[0] = 0.0
x_values[0] = x0
y_values[0] = y0
z_values[0] = z0
vx = vx0
vy = vy0
vz = vz0

# Simulation loop
for i in range(1, num_steps):
    # Update time
    t_values[i] = t_values[i-1] + dt

    # Compute acceleration due to gravity
    r = np.sqrt(x_values[i-1]**2 + y_values[i-1]**2 + z_values[i-1]**2)
    ax = -G * M * x_values[i-1] / r**3
    ay = -G * M * y_values[i-1] / r**3
    az = -G * M * z_values[i-1] / r**3

    # Update velocity using Euler method
    vx += ax * dt
    vy += ay * dt
    vz += az * dt

    # Update position using Euler method
    x_values[i] = x_values[i-1] + vx * dt
    y_values[i] = y_values[i-1] + vy * dt
    z_values[i] = z_values[i-1] + vz * dt

# Plot the trajectory
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot(x_values, y_values, z_values)
ax.set_xlabel('X (m)')
ax.set_ylabel('Y (m)')
ax.set_zlabel('Z (m)')
ax.set_title('Space Debris Trajectory in LEO')
plt.show()

import bpy

# Create a cube mesh object
bpy.ops.mesh.primitive_cube_add(size=1)

# Get a reference to the cube object
cube_object = bpy.context.object

# Set keyframes for the cube's location at frame 1 and frame 50
cube_object.location = (0, 0, 0)
cube_object.keyframe_insert(data_path="location", frame=1)
cube_object.location = (5, 5, 5)
cube_object.keyframe_insert(data_path="location", frame=50)